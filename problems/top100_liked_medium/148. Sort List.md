### [148. Sort List](https://leetcode.com/problems/sort-list/)

linked list,sort

---

#### V1，大佬，迭代法（top-down归并排序）

**中心思想：**
- 时间复杂度来看是归并排序或者快速排序。但是要求空间复杂度是o1，那么只能是bottom-up的归并排序了。但是bottom-up好难，我先弄懂top-down就好。
bottom-up在v2里。

**代码：**
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

/*时间复杂度来看是归并排序或者快速排序*/
// Author: Huahua
// Running time: 6 ms
class Solution {
  public ListNode sortList(ListNode head) {
    //如果传入的是空节点或者只有一个节点。直接返回。
    if (head == null || head.next == null) return head;
    ListNode slow = head;
    /*这里fast和slow的初始位置不同，可能是为了折半的特性，这样才好分出mid。因为前面
      先判断了输入的链表的长度至少为两个。所以fast从head.next开始可以帮助把一个
      长度为二的节点直接分开。*/
    ListNode fast = head.next;
    
    //用快慢指针，把链表对半分开
    while (fast != null && fast.next != null) {
      fast = fast.next.next;
      slow = slow.next;
    }
    ListNode mid = slow.next;
    //断开链表的前后半
    slow.next = null;
      
    /*这个递归是归并排序的精髓。本来开始不知道是怎么保证传入merge的两个链表都是顺序的。
    现在看这个递归，程序总是把链表二分，分到最后一个节点的时候，输入merged函数
    的两个sorted函数都只返回一个节点，那么merge会把这两个节点先升序组合起来。merge的
    返回项又作为sortlist的返回项，而这个时候返回的是有两个节点的升序数组。依次返回递归，
    下一次sortlist返回的是有序的四个节点。最终返回有序的整个链表。*/
    return merge(sortList(head), sortList(mid));
  }
  
  /*把输入的两个有序链表（sortList决定了输入的链表是有序的），按照从小到大产生新链表。
  并返回*/
  private ListNode merge(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode(0);
    //tail是当前处理的准备返回的有序链表的结尾
    ListNode tail = dummy;
      
    /*把两个链表中较小的加入返回链表。其实也不是加入链表，而是把他们相应连接上，这样
      也没占用额外内存*/
    while (l1 != null && l2 != null) {
      /*如果l1不是较小的，不止交换l1和l2两个节点，而是l1及后面的节点（l1为头的链表）
      整体换成l2开头的链表。而l2开头的链表相应的整体换成l1开头的链表。这样总是能
      保证l1和l2都是升序的，且交换链表后，l1指向链表的的头结点（即l1本身）的数值必定比
      l2指向链表的的头结点（即l2本身）的数值小。
      
      比如，如果l1处理到很后面（l1链表很短了）才发现比l2的头结点大，那么l2就会被·换成
      那个很短的链表，l1换成上一步时l2指向的链表。
      */
      if (l1.val > l2.val) {
        ListNode tmp = l1;
        l1 = l2;
        l2 = tmp;
      }
      //因为上面处理完后，l1总是较小的，把l1指向的节点连到tail后面，准备返回。
      tail.next = l1;
      
      /*当前l1被处理了，所以l1后移一位。tail后面也加上了一个节点，所以为了保证tail
        始终在返回链表的结尾，tail也得后移一位*/
      l1 = l1.next;
      tail = tail.next;
    }
    //至少一个链表处理完后，退出了while循环，这里直接把剩下的有序链表连在返回链表的后面
    tail.next = (l1 != null) ? l1 : l2;
      
    return dummy.next;
  }
}
```

---

#### V2，完美切合题目要求的：bottom-up归并排序

**中心思想：**
- 比较难，先掌握简单的吧。

**代码：**
```java
public ListNode sortList(ListNode head) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        int n = 0;
        while (head != null) {
            head = head.next;
            n++;
        }
        
        for (int step = 1; step < n; step <<= 1) {
            ListNode prev = dummy;
            ListNode cur = dummy.next;
            while (cur != null) {
                ListNode left = cur;
                ListNode right = split(left, step);
                cur = split(right, step);
                prev = merge(left, right, prev);
            } 
        }
        
        return dummy.next;
    }
    
    private ListNode split(ListNode head, int step) {
        if (head == null) return null;
    	
        for (int i = 1; head.next != null && i < step; i++) {
            head = head.next;
        }
        
        ListNode right = head.next;
        head.next = null;
        return right;
    }
    
    private ListNode merge(ListNode left, ListNode right, ListNode prev) {
        ListNode cur = prev;
        while (left != null && right != null) {
            if (left.val < right.val) {
                cur.next = left;
                left = left.next;
            }
            else {
                cur.next = right;
                right = right.next;
            }
            cur = cur.next;
        }
        
        if (left != null) cur.next = left;
        else if (right != null) cur.next = right;
        while (cur.next != null) cur = cur.next;
        return cur;
    }
    ```
