### [49. Group Anagrams](https://leetcode.com/problems/group-anagrams/)

hashtable, string

---

#### V1,大佬，Array.sort法

**中心思想：**
- 把每个字符串转换成字符数组，然后对数组排序。建立一个map，把排序后的字符串作为key，把未被排序的原始字符串组成的集合当做value。

**算法描述：**
1. 见代码注释

**代码：**
```java
   public List<List<String>> groupAnagrams(String[] strs) {
        //处理特殊字符串
        if (strs == null || strs.length == 0) 
            return new ArrayList<>();
        //key为排序后的数组，value为未被排序的原始字符串组成的集合    
        Map<String, List<String>> map = new HashMap<>();
        
        //遍历输入的每个字符串
        for (String s : strs) {
            //把字符串转化成字符数组，因为字符数组可以用数组的特性Arrays.sort()进行排序
            char[] ca = s.toCharArray();
            Arrays.sort(ca);
            
            //因为map的key必须使一个类，而数组不是一个类。所以把数组转化成字符串
            String keyStr = String.valueOf(ca);
            
            //如果没有这个key，加入这个map，所以map里现在必定有这个key了。再把当前字符串加到当前key对应的value里。这两句可以用getOrDefault()代替
            if (!map.containsKey(keyStr)) map.put(keyStr, new ArrayList<>());
            map.get(keyStr).add(s);
        }
        
        //!!!map.values返回的是所有映射的value，作为一个collection返回。
        return new ArrayList<>(map.values());
    }
```

---

#### V2,大佬，用26位的数组

**中心思想：**
- 用26位的数组统计每个字符出现的次数，避免使用字符过长时容易出错的Arrays.sort()
- 与V1相比，当计算key的时候，可以把时间复杂度从 O(nlgn) 减少到 O(n).

**注意点：**
- 每个char其实就是int，每个char都是有对应int值的。int的默认为0，对象的默认为null。随意这里是一个值全为0的，类型为char[]的数组
- 大佬说。char[]比int[]性能好，虽然他们本质上都是int，我不知道为啥。
- 字符之间相减，可以得到他们asill码之差的整数
- String.valueOf(char[])是String.toCharArray()的逆过程
- map.values返回的是所有映射的value，作为一个collection返回。

**算法描述：**
1. 见代码注释

**代码：**
```java
 public List<List<String>> groupAnagrams(String[] strs) {
        if (strs == null || strs.length == 0) return new ArrayList<>();
        Map<String, List<String>> map = new HashMap<>();
        
        for (String s : strs) {
            //每个char其实就是int，每个char都是有对应int值的。int的默认为0，对象的默认为null。随意这里是一个值全为0的，类型为char[]的数组
            //!!!大佬说。char[]比int[]性能好，虽然他们本质上都是int，我不知道为啥。
            char[] ca = new char[26];
            
            //对每个输入字符串，统计他的各个字符出现的次数。字符之间相减，可以得到他们asill码之差的整数，正好作为字符串索引。
            for (char c : s.toCharArray()) 
                ca[c - 'a']++;
            
            //像v1说的，数组不能做key，所以改成字符串。如果a出现2次，b出现0次，c出现4次。那么当前字符串的key就是“204”。
            //!!!本步骤是string.toCharArray()的逆过程
            String keyStr = String.valueOf(ca);
            
            if (!map.containsKey(keyStr)) map.put(keyStr, new ArrayList<>());
            map.get(keyStr).add(s);
        }
        
        //!!!map.values返回的是所有映射的value，作为一个collection返回。
        return new ArrayList<>(map.values());
    }
```
