### [221. Maximal Square](https://leetcode.com/problems/maximal-square/)

dp

---

#### V1，大佬
**中心思想：**
- 从左上角往右下角遍历，同时每个元素能构成的最大方形边长可以由left,up,upleaft得到。
这样就相当于先处理左上角范围的方形，然后利用左边上边和左上的能构成最大方形的结果，求当前元素为能得到的最大矩形边长。
- 代码和思想概要可以看[youtube米开](https://www.youtube.com/watch?v=5AfIa6z3Yw0)
- 详细图解和详细思想可以看[youtube花花](https://www.youtube.com/watch?v=vkFUB--OYy0&t=27s)
- 根据花花的图示，以二维数组中某位置为右下角且能构成的最大方形的数目，与该位置左边，上边，和左上位置能产出的最大矩形边长有关。那三个位置的
最小值加一为当前位置能形成的最大矩形的边长。

**注意点：**
- 碰到graph问题（二维数组问题），考虑动态规划。核心就是从上往下从左往右遍历，但是每个节点的值尝试由left,up,（和upleft）得到。

**代码：**
```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        int row = matrix.length;
        int col = matrix[0].length;
        int ans = 0;
        
        //处理特殊值，防止后面访问数组出现nullpointerexception的问题
        if(row<=0) 
          return ans;
        
        /*处理边界条件，先处理第一列，只要第一列有一个元素不为0，那么整个矩阵包含至少最大方形边长为1*/
        for(int i = 0; i<row; i++)  
            if(matrix[i][0]=='1') 
                ans =1;
        
        /*如果第一列全为0，再查看第一列里面有没有1
        
        为什么这么做？：因为双重for循环里要用left,up,upright的值，所以循环的起始点得从第二行和第二列开始，否则会超过数组边界。
        所以没办法处理第一行和第一列，同时第一行和第一列本身只能支撑边长为1的方形，所以处理矩阵其余部分之前要先把第一行和
        第一列处理了，一旦他们能存在边长为1的矩形，更新ans。*/
        if(ans<1) 
            for(int j = 0; j<col; j++)  
                if(matrix[0][j]=='1') 
                    ans =1;    
        
        /*处理完第一行和第一列了，，现在对矩阵其余位置，根据以left,up,upright位置为右下角的最大边长方形，求当前位置为右下角时能支持
        多大的方形*/
        for(int i = 1 ; i <row; i++){
            for(int j = 1;j<col; j++){
                int cur = matrix[i][j];
                /*如果当前节点是0，则不会构成更大的矩形。直接跳过
                
                如果当前节点为1，更新该位置的值为：left,up,upright能支撑的最大边长方形里的最小值+1
                ！！！注意这个矩阵是字符数组*/
                if(cur!='0'){
                    int up = matrix[i-1][j] - '0';
                    int left = matrix[i][j-1] - '0';
                    int ul = matrix[i-1][j-1] - '0';
                    
                    int temp =Math.min(up,Math.min(left,ul))+1;
                    //每次填写元素的时候，都得尝试更新一下最大边长
                    ans = Math.max(ans,temp);
                    matrix[i][j] =(char)(temp +'0'); 
                }
                 //System.out.print(matrix[i][j]);
            }
             //System.out.println("");
        }
        
        //二维数组全部遍历完后，可以直接返回anser^2作为最大面积
        return ans*ans;
    }
}
```
