### [146. LRU Cache](https://leetcode.com/problems/lru-cache/)

design

---

#### V1，大佬，hashmap+双向链表
**中心思想：**
- 查找o（1）用hashtable（map）实现。put是更新插入，想在o（1）时间复杂度只能用双向linkedlist实现，因为单向链表的增添和删除时间复杂度都是o（n）。
- 这种实现数据结构的题，内部构造可以尽量用语言自带的数据结构，比如hashmap，linkedlist。比较保险。

**注意点：**
- 注意类中，构造函数的定义方式
- remove方法中，可以加上
  ```java
  node.prev = null;
  node.next = null;
  ```
  便于当前节点脱离整个链表，让他进入java的垃圾回收装置。

**代码：**
```java
class LRUCache {
  
  Node head = new Node(0, 0), tail = new Node(0, 0);
  /*map的key value组合是一个hashtable，帮助在o（1）的时间复杂度内定位到目标节点。node是一个双向链表的节点，选择双向链表是为了
  在o（1）的时间复杂度内完成增添删除功能（put）
  
  o（1）的定位和增删使得我们需要hashtable和双向链表两个数据结构组合到一起*/
  Map<Integer, Node> map = new HashMap();
  int capacity;
  
  public LRUCache(int _capacity) {
    capacity = _capacity;
    head.next = tail;
    tail.prev = head;
  }

  public int get(int key) {
    /*如果map里有这个节点，把该节点从map的value链表的原位置移动到value链表的开头。因为他是most recent used了。然后返回这个节点。*/
    if(map.containsKey(key)) {
      Node node = map.get(key);
      //从hashmap的value双向链表中移除
      remove(node);
      //插入到hashmap的value双向链表的开头
      insert(node);
      return node.value;
    } 
    /*如果节点不存在，按照题意直接返回-1*/
    else {
      return -1;
    }
  }

  public void put(int key, int value) {
    //当想插入一个key和value时，如果这key存在，则删掉他。因为hashmap的key将要对应当前输入的这个最新的value
    if(map.containsKey(key)) {
      remove(map.get(key));
    }
    //如果map的value满了，删掉map的value双向链表的最后一个节点。通过预定义的tail，访问tail的前一个节点得到。
    if(map.size() == capacity) {
      remove(tail.prev);
    }
    //map中现在不可能有当前输入key了，也不可能是满的，所以安心加入map的value双向链表。insert是插在链表的最开头。
    insert(new Node(key, value));
  }
  
  //删掉map的value双向链表的最后一个值
  private void remove(Node node) {
    map.remove(node.key);
    node.prev.next = node.next;
    node.next.prev = node.prev;
  }
  
  //把一个节点插入到map的value双向链表的开头
  private void insert(Node node){
    map.put(node.key, node);
    Node headNext = head.next;
    head.next = node;
    node.prev = head;
    headNext.prev = node;
    node.next = headNext;
  }
  
  //双向链表的数据结构。有pre，有next
  //!!!注意构造函数的定义方式
  class Node{
    Node prev, next;
    int key, value;
    Node(int _key, int _value) {
      key = _key;
      value = _value;
    }
  }
}
```
