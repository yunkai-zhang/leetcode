### [139. Word Break](https://leetcode.com/problems/word-break/)

dynamic programming

---

#### V1，自己，失败版

**中心思想：**
- 最后有个比较复杂的用例超时了，应该是我的时间复杂度太高了。所以判断时间复杂度很重要，像我这样按照高时间复杂度算法编程半天结果失败，比较划不来。
- 判断trueorfalse可以用动态规划。动态规划就是先处理问题的一部分（常常是基础底层的小问题），再递推到大问题。
这里可以把dict先全部放到hashset里（hash的另一个应用是hashmap）。
        然后对一个字符比较字典里有没有，没有的话查看前两个字符，如果查到了，left和right指针移到当前字符后面并重合。然后继续移动right指针进行查找。
- dp的一个特点就是记忆化递归，但是我的代码没有实现记忆化。比如，字符串s的后半部分会被前面不同递归反复求解。
导致时间复杂度暴增，使得碰到复杂或者比较长的代码就会超时。

**注意点：**
- 判断存在不需要hashset，list中的contains就能实现目的。
- 递归中要用charat的时候，要在递归函数的开始先判断charat（）的index是否还在字符串的范围内。避免访问超过限制。
- 设置边缘值（返回值），这是dp最重要的部分。确保有true和false两者的返回。
- 如果for循环里嵌套char[i]，注意i的值不会超过字符数组预先设置的范围。


**代码：**
```
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        /*判断trueorfalse可以用动态规划。动态规划就是先处理问题的一部分（常常是基础底层的小问题），再递推到大问题。这里可以把dict先全部放到hashset里（hash的另一个应用是hashmap）。
        然后对一个字符比较字典里有没有，没有的话查看前两个字符，如果查到了，left和right指针移到当前字符后面并重合。然后继续移动right指针进行查找
        !!!判断存在不需要hashset，list中的contains就能实现目的*/
        
        if(s==null||s.length()==0)
            return false;
        
        return dp(s,wordDict,0,0);
    }
    
    public boolean dp(String s,List<String> wordDict,int left,int right)
    {
        /*!!!这里处理right超过或者到达边界的情况。因为后面charat涉及字符串index，先处理它可以防止超过边界
        当右边界超过数组长度一位时，如果left=right说明完整的遍历了上一个节点。若left!=right则说明函数到结尾都没有符合的字符串，返回false*/
        if(right==s.length())
        {
            if(right==left)
                return true;
            else
                return false;
        }
            
        
        //构建目标字符串
        char[] tempChars=new char[right-left+1];
        for(int i=left;i<=right;i++)
        {
            //System.out.println("s.length():"+s.length());
            /*!!!如果直接tempChars[i],在leet完后的c会报错。因为left=right=4，所以字符数组长度为1
             * 但是这里的i却为4，直接超过了字符数组的范围*/
            tempChars[i-left]=s.charAt(i);
        }
            //tempChars[i]=0;
        String tempString=String.valueOf(tempChars);
        
        //如果list存在当前字符串，移动指针进行下一次递归查找。保留结果。
        /*!!!但是不能直接返回，因为当前匹配的可能后面走不通。反而后面匹配的当前走得通。所以保存结果是最好的*/
        //!!!设置边缘值（返回值），这是dp最重要的部分。确保有true和false两者的返回
        boolean tempBoolean=false;
        if(wordDict.contains(tempString))
        {
            // if(right==s.length()-1)
            //     return true;
            tempBoolean=dp(s,wordDict,right+1,right+1);
        }
        
        //不管当前字符串存在于dict与否，都得right++查找。因为当前字符串符合后面可能不符合了
        return dp(s,wordDict,left,right+1)||tempBoolean;
        
            
    }
}
```
