### [78. Subsets](https://leetcode.com/problems/subsets/)

array, backtracking, bit manipulation

---

#### V1，自己失败bt

**疑问**
- 第一层迭代里，输入的是“”字符串，那么它应该分别和1,2,3结合。但是运行结果里所有的集合都是1开头的，无法理解。
这体现了他的第一层迭代的循环貌似只执行了一次。
- 列表加入123后，又一次加入12。按理来说应该加完123后一直退栈到1，然后执行13

**代码：**
```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        
        List<List<Integer>> result =new ArrayList<>();
        backtracking(nums,0,"",result);
        
        return result;
    }
    
    public void backtracking(int nums[], int curIndex, String curStr, List<List<Integer>> result)
    {

        
        for(int i=curIndex; i<nums.length; i++)
        {
            
            //先构成当前字符串,不能直接复写，因为构成12后curstr变成12，再处理3就没办法实现13了
            String curStrI=curStr+(nums[curIndex]+"");

            //再判断
            //用整数组成的字符串作为key，数组内容作为其对应列表
            //或者整数字符串直接tochararray,再用aslist构建成list
            //toCharArray()用法：str.toCharArray()
            //aslist用法：arrays.aslist(arr),返回list
            List<Integer> curList=new ArrayList<>();
            for(int j=0;j<curStrI.length(); j++)
            {
                //!!!不要直接把char喂给integer.valueof,数值会出错。要先把char变成string再喂给integer.valueof
                String tempStr=String.valueOf(curStrI.charAt(j));
                int curInt=Integer.valueOf(tempStr);
                curList.add(curInt);
            }
            result.add(new ArrayList(curList));
            
            //递归调用，附加字符串
            backtracking(nums, i+1, curStrI, result);
        }
        
        /*如是[1,2,3]调用结果是：1 12 123 13 2 23 3*/
        
    }
}
```

#### V2，自己失败，bt

**中心思想：**
- v1的基础上改进，现在能处理非负整数的组合。下一步把string替换成list，这样就能处理负整数了。
- 出现“整数”字样的时候，注意是正整数还是能包含负整数。

**代码：**
```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        
        List<List<Integer>> result =new ArrayList<>();
        backtracking(nums,0,"",result);
        
        //空数组没有被加进去，补充加入空数组
        result.add(new ArrayList<>());
        
        return result;
    }
    
    public void backtracking(int nums[], int curIndex, String curStr, List<List<Integer>> result)
    {

        
        for(int i=curIndex; i<nums.length; i++)
        {
            
            //先构成当前字符串,不能直接复写，因为构成12后curstr变成12，再处理3就没办法实现13了
            /*!!!"String curStrI=curStr+(nums[curIndex]+"");"肯定是错的，因为中括号里应该是i。难怪一直非空列表的第一个元素都是1*/
            String curStrI=curStr+(nums[i]+"");
            // System.out.println("curStr:"+curStr);
            // System.out.println("curStrI:"+curStrI+"\n");

            //再判断
            //用整数组成的字符串作为key，数组内容作为其对应列表
            //或者整数字符串直接tochararray,再用aslist构建成list
            //toCharArray()用法：str.toCharArray()
            //aslist用法：arrays.aslist(arr),返回list
            List<Integer> curList=new ArrayList<>();
            for(int j=0;j<curStrI.length(); j++)
            {
                //!!!不要直接把char喂给integer.valueof,数值会出错。要先把char变成string再喂给integer.valueof
                /*!!!处理整数的时候不要忽略负整数，因为-1的话，切分字符串会出现“-”，无法转化成数字。
                
                这里string的作用相当于List<integer>,所以为什么不直接用list呢？*/
                String tempStr=String.valueOf(curStrI.charAt(j));
                int curInt=Integer.valueOf(tempStr);
                curList.add(curInt);
            }
            result.add(new ArrayList(curList));
            
            //递归调用，附加字符串
            backtracking(nums, i+1, curStrI, result);
        }
        
        /*如是[1,2,3]调用结果是：1 12 123 13 2 23 3*/
        
    }
}
```
