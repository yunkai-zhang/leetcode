### [96. Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees/)

dynamic programming, tree

---

#### V1，大佬，数学加上动态规划

**中心思想：**
- 如果问题问数目或者true or false，那么一般可以考虑动态规划
- 加入g[n]是指n个节点能构成多少二叉搜索树。那么对于每个节点，其可能的二叉搜索树的数目=该节点左侧所有节点可能构成的二叉搜索树的数目*该节点右侧所有节点
可能构成的节点数目。而g[0]=g[1]=1，因为没有节点或者只有一个节点的时候肯定只能有一种二叉搜索树。
所以可以递归的，用g[0]g[1]求g[2],再用g[0]g[1]g[2]求g[3]。最后可以求出g[n]为多少。

**代码：**
```java
public int numTrees(int n) {
  int [] G = new int[n+1];
  G[0] = G[1] = 1;
    
  for(int i=2; i<=n; ++i) {
    for(int j=1; j<=i; ++j) {
      //G[j-1]表示j节点左边那么多节点可能构成的二叉搜索树的数目。G[i-j]表示j节点右侧一直到i（最后一个节点）的那么多节点数能构成的二叉搜索书的数目   
      G[i] += G[j-1] * G[i-j];
    }
  }
  return G[n];
}
```
