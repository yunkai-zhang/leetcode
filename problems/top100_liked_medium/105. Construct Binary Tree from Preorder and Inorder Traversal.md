### [105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

array,tree,dfs

---

#### V1，大佬，指针划分数组

**代码：**
```java
public TreeNode buildTree(int[] preorder, int[] inorder) {
    return helper(0, 0, inorder.length - 1, preorder, inorder);
}

public TreeNode helper(int preStart, int inStart, int inEnd, int[] preorder, int[] inorder) {
    if (preStart > preorder.length - 1 || inStart > inEnd) {
        return null;
    }
    TreeNode root = new TreeNode(preorder[preStart]);
    int inIndex = 0; // Index of current root in inorder
    for (int i = inStart; i <= inEnd; i++) {
        if (inorder[i] == root.val) {
            inIndex = i;
        }
    }
    root.left = helper(preStart + 1, inStart, inIndex - 1, preorder, inorder);
    root.right = helper(preStart + inIndex - inStart + 1, inIndex + 1, inEnd, preorder, inorder);
    return root;
}
```

---

#### V2，大佬，再v1基础上用HashMap空间换时间

**代码：**
```java
public TreeNode buildTree(int[] preorder, int[] inorder) {
    
    //记录下中序数组中每个值所在的index，避免每次查找节点都要做一次遍历中序数组。空间换时间。
    Map<Integer, Integer> inMap = new HashMap<Integer, Integer>();
    for(int i = 0; i < inorder.length; i++) {
        inMap.put(inorder[i], i);
    }

    TreeNode root = buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1, inMap);
    return root;
}

/*参数依次为：先序数组，当前子树在先序数组中第一次出现的地方，当前子树在先序数组中结尾的地方（出现和结尾中间必定是连贯的）
中序数组，当前子树在中序数组中的起始位置，当前子树在中序数组中的结束位置，用于记录中序数组值和index的map*/
public TreeNode buildTree(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd, Map<Integer, Integer> inMap) {
    //如果pre和end重合，那么至少还有一个节点能返回给上一层节点做子节点。但是pre和end错位的话，说明没有节点了，说明上一层节点的该子节点位置为空
    if(preStart > preEnd || inStart > inEnd) return null;
    
    //先序数组的第一个说明是根节点。建立一个节点，并给构造函数传入该节点的值。
    TreeNode root = new TreeNode(preorder[preStart]);
    //再找当前节点在中序数组中的位置，来寻找当前节点左右子树分别的节点个数。
    int inRoot = inMap.get(root.val);
    //当前节点左子树里节点的个数
    int numsLeft = inRoot - inStart;
    
    /*左子树递归参数讲解：
    依然传入先序数组。
    当前处理了先序数组的第一个节点，把它放入root中。当前节点左子树的先序数组的开头就是当前节点的后一个。!!!本题按照了先序遍历的顺序构件树。
    按照中序数组得到左子树的节点个数numsleft，所以prestart（先序数组中当前节点的位置）+左子树节点个数=当前节点左子树的先序数组的结尾。
    老规矩传入中序数组。
    当前节点左子树的中序数组的开头依然是之前的开头
    当前节点左子树的中序数组的结尾，是中序数组当前节点位置的左边一位，即inRoot - 1
    */
    root.left = buildTree(preorder, preStart + 1, preStart + numsLeft, inorder, inStart, inRoot - 1, inMap);
    /*右子树递归参数讲解：
    依然传入先序数组。
    当前节点右子树的先序数组的开头，就是当前节点的后走完左子树的范围后的第一个节点。
    当前节点右子树的先序数组的结尾依然是之前的结尾。
    老规矩传入中序数组。
    当前节点右子树的中序数组的开头是中序数组中的当前节点值的右边一位。
    当前节点右子树的中序数组结尾依然是之前的结尾。
    */
    root.right = buildTree(preorder, preStart + numsLeft + 1, preEnd, inorder, inRoot + 1, inEnd, inMap);

    return root;
}
```

---
