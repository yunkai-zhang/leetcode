### [207. Course Schedule](https://leetcode.com/problems/course-schedule/)

dfs,bfs,topologic sort,graph

---

#### V1，花花，拓扑排序判断有没有循环

**代码：**
```java
// Author: Huahua
// Runtime: 6 ms
// HashMap is slower than ArrayList in this problem.
class Solution {    
    public boolean canFinish(int numCourses, int[][] prerequisites) {        
        ArrayList<ArrayList<Integer>> graph = new ArrayList<>();
        
        //构建一个空图，prerequisites的每一行都是图的一条边
        for (int i = 0; i < numCourses; ++i)
            graph.add(new ArrayList<Integer>());
        
        /*把数组转换成创建好的图。course是第一层arraylist中，先修课的编号。prerequisite是第二层arraylist中的项。
        虽然当前边在第二层arraylist只有一个节点，但是后续可能再次出现当前course，只不过指向了不同选修课。那么第二层arraylist存储的节点又增加了。
        
        这个序号和值们搭配的感觉其实类似hashmap，但是花花在程序开头就说了，双重arraylist比hashmap要快一点
        
        下面这个for循环遍历每个edge，并构造edge第一个节点（相当于key，用arraylist中的位置表示）和第一个节点指向的第二个节点们的对应。*/
        for (int i = 0; i < prerequisites.length; ++i) {
            int course = prerequisites[i][0];
            int prerequisite = prerequisites[i][1];            
            graph.get(course).add(prerequisite);
        }
        
        /*先广度遍历，对每个节点再做dfs，判断他们导向的节点是否能构成环*/
        /*建立一个visited数组，记录那些节点被访问了。数组的index表示course。数组某index的value表示该course被访问与否。
        
        0是初始化状态，标水unknow状态
        1表示visiting，即正在当前查找路径中。如果遍历时查找节点发现是visiting，那么表示当前发现一条路径循环了，直接返回false
        2表示visited，即当前节点之前遍历过了，属于一个不循环的路径。*/
        int[] visited = new int[numCourses];
        for (int i = 0; i < numCourses; ++i)
            //当发现某个节点是visiting的时候，dfs返回true，表示有循环。之后当前函数就会返回false，表示选课系统构建失败。
            if (dfs(i, graph, visited)) return false;
        
        //如果广度遍历后，都没有发现节点可以导向一个环，那么返回ture。表示当前选课系统合理，选修课之前不会相互矛盾。
        return true;
    }
    
    /*dfs用来遍历图，对每个节点，看看他能不能引出一条路径构成一个环*/
    private boolean dfs(int curr, ArrayList<ArrayList<Integer>> graph, int[] visited) {
        //!!!这里利用一个性质，数组不是基本数据类型，所以传数组传的是地址，所有层的dfs对数组做的更改会体现在其它层
        //如果当前节点被标记为visting，说明路径成环了，选课系统有问题
        if (visited[curr] == 1) return true;
        //如果当前节点是visited，说明当前路径走到这都是正常的，没有构成环。
        if (visited[curr] == 2) return false;
        //如果当前节点是unknow，那么来处理这个节点
        
        //当前节点是unknow，现在开始处理，查看是否有循环，所以把状态更改成 1 visiting
        visited[curr] = 1;
        /*对当前节点导向的每个节点，进行遍历，查看是否有循环
        graph.get(curr)把cur节点（course）导向的所有节点（先修课）都遍历了*/
        for (int next : graph.get(curr))
            if (dfs(next, graph, visited)) return true;
        
        //对当前节点所有能导向的节点都遍历完后，没发现循环。说明当前节点是安全的良好的，把它标记为visited，并返回false，进行下一个cur的遍历
        visited[curr] = 2;
        return false;
    }
 
}
```
