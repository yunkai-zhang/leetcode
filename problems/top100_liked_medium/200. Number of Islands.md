### [200. Number of Islands](https://leetcode.com/problems/number-of-islands/)

dfs,bfs,union find

---

#### V1,大佬第一层bfs，第二层dfs

**中心思想：**
- 先广度遍历这个数组1，一旦发现1，就说明有小岛了，就给结果加一。然后通过深度遍历把当前1及周围都变成0，即沉没当前小岛，便于下一个小岛的探测。
- 这是一道关于深度遍历和广度遍历的好题。

**代码：**
```java
// Author: Huahua
// Time Complexity: O(mn)
// Running time: 13 ms
class Solution {
    public int numIslands(char[][] grid) {
        int m = grid.length;
        if (m == 0) return 0;
        int n = grid[0].length;
        
        int ans = 0;
        //第一层bfs遍历，一旦发现1，就说明有个海岛。并且深度遍历把当前1周围都变成0（让当前小岛沉没）
        for (int y = 0; y < m; ++y)
            for (int x = 0; x < n; ++x)
                if (grid[y][x] == '1') {
                    ++ans;
                    dfs(grid, x, y, n, m);
                }
        
        return ans;
    }
    
    //每个传入的节点都需要把四周的1全部变成0
    private void dfs(char[][] grid, int x, int y, int n, int m) {
        if (x < 0 || y < 0 || x >= n || y >= m || grid[y][x] == '0')
            return;
        grid[y][x] = '0';
        dfs(grid, x + 1, y, n, m);
        dfs(grid, x - 1, y, n, m);
        dfs(grid, x, y + 1, n, m);
        dfs(grid, x, y - 1, n, m);
    }
}
```
