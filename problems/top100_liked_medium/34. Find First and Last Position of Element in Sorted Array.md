### [34. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

array, binary search

---

#### V1，看过大佬花花写的后临时默写版，二分查找

**中心思想：**
- 时间复杂度要求是o(logn),所以是折半查找。
- 两个函数分别查找上边界和下边界，虽然二分查找了两次，但是是常数倍数，所以时间复杂度还是o(logn)
- 花花视频：<https://www.youtube.com/watch?v=v57lNF2mb_s>。花花的思想是[l,r)为查找区间,l不断向r靠，最后两个指针重合于r。
- 左闭右开的二分查找：<https://blog.csdn.net/wingWC/article/details/78229684>

**注意点：**
- 二分查找一般都用左闭右开模型。<br/>
 while(low<high)<br/>
 mid=low+(high-low)/2;<br/>
 if(nums[mid]>=target)//这里大于或者大于等于都可以商量。如果要求时刻查找中间值则为：if(nums[mid]>target)else if(nums[mid]<target) else 返回mid<br/>
   high=mid;//`右开的重要体现`，因为mid被舍弃，同时r=mid，体现了r不在查找范围内<br/>
 else<br/>
   low=mid+1;//`左闭的重要体现`<br/>
- 如果是查找左边界，则尽量把右指针左移。如果是查找右边界，则尽量把左指针右移。这里的“尽量”体现在用“大于等于”而非“大于”
- 当higherbound要用到low-1为数组索引的时候，要留意这个low为0的时候，索引可能就会脱离数组边界。所以要多做一些判定。
- 对于二分查找，用左闭右开的模型可以避免遗漏情况。但是最后指针是否停留在目标值上不是一定的。他可能总是停留在目标值的左边一个或者右边一个
（就像higherbound）。这时候就需要自己用if语句调整一下来得到合适值。并且如果指针不停留在目标值上，那么考虑它停留的值是否总是存在。比如12234（查2）
指针停留在3是因为有比2大的数，但如果可考虑2222（查2）就没有指针可以停留了，因为没有数存在于2的右边。
- 

**代码：**
```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        //n(logn)是折半查找的特征
        //用两个函数，分别查找lowboud和highboud
        return new int[]{findLowerBound(nums,target),findHigherBound(nums,target)};
        
    }
    
    public int findLowerBound(int[] nums, int target)
    {
        //用花花模板左闭右开试试
        if(nums.length==0)
            return -1;
        
        int low=0, high=nums.length-1,mid;
        while(low<high)
        {
            //因为不用查找某个具体值，mid不需要在查找的过程中返回。只在最后两个指针重合的时候考虑返回谁
            mid=low+(high-low)/2;
            if(nums[mid]>=target)
                high=mid;//左闭右开，因为右不取，所以可以直接等于被排除掉的target
            else
                low=mid+1;
        }
        //根据例子12234（找2）和123333456（找3）可知，离开循环后，两个指针重合与目标坐标
        //根据例子124456（找3）可知，寻找指针最后重合与4，nums不存在target，返回-1；
        return nums[low]==target?low:-1;
    }
    
     public int findHigherBound(int[] nums, int target)
    {
        //用花花模板左闭右开（bug free）试试：《https://www.youtube.com/watch?v=v57lNF2mb_s》
        if(nums.length==0)
            return -1;
        
        int low=0, high=nums.length-1,mid;
        while(low<high)
        {
            //因为不用查找某个具体值，mid不需要在查找的过程中返回。只在最后两个指针重合的时候考虑返回谁
            mid=low+(high-low)/2;
            if(nums[mid]>target)//求upperbound就尽可能把左指针右移
                high=mid;//左闭右开，因为右不取，所以可以直接等于被排除掉的target
            else
                low=mid+1;
        }
        //根据例子12234（找2）和123333456（找3）可知，离开循环后，两个指针重合与目标坐标+1
        //根据例子124456（找3）可知，寻找指针最后重合与4，nums不存在target，返回-1；
         //!!!直接“return nums[low-1]==target?low-1:-1;”对于1111（求1）会结果出错,
         //!!!直接“return nums[low-1]==target?low-1:-1;”对于1（求0）会索引超过数组边界。所以数组的索引一定要小心,
         if(nums[low]==target)
             return low;
         else if(low==0)
             return -1;
         else if(nums[low-1]==target)
             return low-1;
         else
             return -1;
        
    }
}
```
