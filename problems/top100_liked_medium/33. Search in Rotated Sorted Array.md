### [33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)

array, binary search

---

#### V1, 大佬，改编折半查找

**中心思想：**
- 本题目标字符串的左升序数组的最小值会大于右升序数组的最大值。所以根据这个特性也可以进行二分查找，但是更新low和high的时候就得随机应变了。

**注意点：**
- 碰到要求时间复杂度为0(logn)时，一般都考虑用折半查找
- 一定要先处理输入数组为空等特殊情况。这里如果数组为空，再访问数组中某元素的值，则会报超出边界的exception

**代码：**
```java
public class Solution {
public int search(int[] A, int target) {

    //先处理特殊值
    if(A.length==0)
        return -1;

    int lo = 0;
    int hi = A.length - 1;
    //折半查找标准结束方式，两个指针重合（或者相差1）
    while (lo < hi) {
        int mid = (lo + hi) / 2;
        //如果找到了目标指针
        if (A[mid] == target) return mid;
        
        /*
        如果是：low指向的值<=mid指向的值
            .
           .(mid)
          .
         .
        .(low)
                .(high)
               .
              .
        */
        if (A[lo] <= A[mid]) {
            if (target >= A[lo] && target < A[mid]) //目标值在前升序数组
            {
                hi = mid - 1;
            } else //目标值在后升序数组
            {
                lo = mid + 1;
            }
        } 
        /*
        如果是：low指向的值>mid指向的值
           .
          .
         .(low)
                 .(high)
                .
               .
              .
             .(mid)
        
        */
        else {
            if (target > A[mid] && target <= A[hi])//目标值在后升序数组
            {
                lo = mid + 1;
            } else //目标值在前升序数组
            {
                hi = mid - 1;
            }
        }
    }
    //若一直没有找到目标值，退出循环时，两个指针重合。重合后的那个值没办法在循环中被判断，所以在这里最后判断一下。这里用lo和le等效
    return A[lo] == target ? lo : -1;
}
}
```
