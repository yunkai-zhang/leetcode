### [21. Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)

---

#### V1，大佬递归法

**中心思想：**
- 某链表的a节点比另一个链表的b节点大的话，b节点及后面所有的节点都应该在a的后面。但是a.next及后面的节点们也在a的后面。
所以，据此可以看出一种递归的感觉。

**代码：**
```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2){
    //设置递归的触底条件
		if(l1 == null) return l2;
		if(l2 == null) return l1;
    
    //递归求出后面的节点
		if(l1.val < l2.val){
			l1.next = mergeTwoLists(l1.next, l2);
			return l1;
		} else{
			l2.next = mergeTwoLists(l1, l2.next);
			return l2;
		}
}
```
---

#### V2，迭代法

**注意点：**
- 他这个是新建了一个链表再给列表不断赋值，不太符合题目中说的：把节点们剪接而成。
- 我发现java里声明一个变量但是不给他新建内存，只是让他引用对象的话，引用的感觉还蛮像指针的。他`引用`不同的对象就像是`指针`指向不同的变量。
- `java中“引用（reference）”和c中“指针”概念的比较：`
  - 每次新增节点后，让prev指针后移一位。prev只是个声明的变量（没有new来新建内存去赋值，所以他引用的对象不是一个新对象），
  给他引用不同的对象的时候，他就可以对那些对象进行操作。<br/>
  
  但是，该对象不仅被他索引着，还被result这个变量索引着（result实例里有层层嵌套的next导向prev指向的对象），
  他们两都可以操作他们索引的那个对象。相当于：prev=result.next.next.next....  
            
  - prev总是代表结果序列的末尾的值。
  - prev的不断移动，不断引用不同的节点对象，相当于指针指在不同位置。

**代码：**
```java
public class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    
        //处理特殊值
        if (l1 == null) {
            return l2;
        }
        if (l2 == null) {
            return l1;
        }
        
        //新建一个c链表用于存放等待返回的链表
        ListNode result = new ListNode(0);
        ListNode prev = result;
        
        //只要a链表的当前节点的值小于b链表的当前节点值，就把这个小值节点赋给c链表，作为他的新增的一个节点
        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
	        //prev.next不再是null了，他引用了l1中的当前节点
                prev.next = l1;
		//下面语句执行后，原l1因为没有被引用了，会被java自动回收
                l1 = l1.next;
            } else {
                prev.next = l2;
                l2 = l2.next;
            }
            /*
            每次新增节点后，让prev指针后移一位。prev只是个声明的变量（没有new来新建内存去赋值，所以他引用的对象不是一个新对象），
            给他引用不同的对象的时候，他就可以对那些对象进行操作
            但是，该对象不仅被他索引着，还被result这个变量索引着（result实例里有层层嵌套的next导向prev指向的对象），
            他们两都可以操作他们索引的那个对象。相当于：prev=result.next.next.next....  
            
            prev总是代表结果序列的末尾的值。
            prev的不断移动相当于指针指在不同位置。
            !!!我发现java里声明一个变量但是不给他新建内存，只是让他引用对象的话，引用的感觉还蛮像指针的）
            */
	    //prev移动，引用下一个节点
            prev = prev.next;
        }
        
        //把没有遍历完的部分附加到结果链表
        if (l1 != null) {
            prev.next = l1;
        }
        if (l2 != null) {
            prev.next = l2;
        }
        
        //返回结果链表（避开他的头结点）
        return result.next;
    }
}
```

---

#### V3，默写v1递归法

**注意点：**
- 当前两个nide小的的那个，会指向自己后面的节点，或者另一链表的当前node。主要看谁小。所以可以看出递归的思想
- 如果不想下面大括号的内容，只写：return l1.next=mergeTwoLists(l1.next,l2);
  则每次相当于返回mergeTwoLists(l1.next,l2)，而对l1.next的赋值是无用的。<br/><br/>
  
  变成了：谁小，就返回他后面的链表和他的敌人链表的进一步递归，而没有进行节点间的黏连操作，所以最后的返回只能是触底条件那返回的一个节点，他被层层上交，返回给最上面的return

**代码：**
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        /*当前两个nide小的的那个，会指向自己后面的节点，或者另一链表的当前node。主要看谁小。所以可以看出递归的思想*/
        //设置递归函数的触底条件：当一个链表遍历完成时，直接返回另一方链表的剩下部分给上一级递归，做他的下一节点
        if(l1==null) return l2;
        if(l2==null) return l1;
        
        if(l1.val<l2.val)
        /*如果不想下面大括号的内容，只写：return l1.next=mergeTwoLists(l1.next,l2);
        则每次相当于返回mergeTwoLists(l1.next,l2)，而对l1.next的赋值是无用的。
        
        变成了：谁小，就返回他后面的链表和他的敌人链表的进一步递归，而没有进行节点间的黏连操作，所以最后的返回只能是触底条件那返回的一个节点，他被层层上交，返回给最上面的return*/
        {
            l1.next=mergeTwoLists(l1.next,l2);
            return l1;
        }
        else
        {
            l2.next=mergeTwoLists(l1,l2.next);
            return l2;
        }
        
    }
}
```
