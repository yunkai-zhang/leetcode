### [101. Symmetric Tree](https://leetcode.com/problems/symmetric-tree/)

---

#### V1，自己失败版本
**中心思想：**
- 广度遍历这颗树，对每层切分开。一层的前一半放进栈中，一层的后一半尝试用栈的后进先出的镜像性（类似判断括号是否正确使用）去和当前栈顶比较，
如果当前栈顶等于当前节点，则当前两节点对称，并弹出栈顶，暴露下一个节点，来判断是否对称，依次进行去判断一层的节点是否对称。再依层遍历全树。
但是我算法实现的太复杂了，失败了。

---

#### V2，大佬，递归（recursive）

**中心思想：**
- 每次只判断当前两个节点是否相同，且子节点是否相同。再递推（递归）到每一个节点
- 原题求两棵树的比较，可以简化为某两个对应节点和他们的子树的比较。有种动态规划的感觉：把大问题化成小问题。但是动态规划时自底而上的。树结构很不适合
自底而上的遍历。所以用自上而下的递归就好

**注意点：**
- [递归和迭代的区别](https://www.jianshu.com/p/32bcc45efd32)
  - 递归是`树`结构，一个函数内部调用自己。迭代是`环`结构，描述重复反馈的活动，每次迭代的结果作为下次迭代的初始值。
  - 递归是函数自身调用自身。迭代是循环，比如for循环，不停地运作，直到循环条件不再满足。
- java中，list==null表示没有杯子，即list只是声明了，但是没创建对象。list.size()==0表示有杯子，但是杯子里没装水。想装水必须买个杯子：
new List()，即创建对象,否则会出现指针错误。
- 用递归的时候，在开头处理特殊情形不仅可以加速程序，也是设置递归的触底条件（必须）
- 这里考虑输入根节点为空时，也为对称树，而t1 == null && t2 == null正好能处理他，返回true

**算法描述：**
1. 确定了递归的思想后，结合递归的树结构，明确树的触底条件：一个节点为空另一个不是，两个节点都为空
2. 如果当前两节点的值和他们的子节点的值对应相等，则说明当前两节点好其子节点对称。这样递归下去，就可以判断整棵树之间是否对称

**代码：**
```java
public boolean isSymmetric(TreeNode root) {
    return isMirror(root, root);
}

public boolean isMirror(TreeNode t1, TreeNode t2) {
    //针对值存在与否，先处理特殊情况。这同样也是在设置递归的触底条件（触碰到递归树结构的底层叶子）
    //若当前节点都是空节点，则肯定都相同
    if (t1 == null && t2 == null) return true;
    //如果当前节点一个空，一个不空，说明当前两节点不相同
    if (t1 == null || t2 == null) return false;
    
    //经过之前判断，得知值都存在，现在得对值本身的内容进行判断。
    //即：当前两个值？相同&&左值的左子节点？等于右值的右子节点&&左值的右子节点？等于右值的左子节点
    return (t1.val == t2.val)
        && isMirror(t1.right, t2.left)
        && isMirror(t1.left, t2.right);
}
```

---

#### V3，迭代法（循环，Iterative），思路类似我之前自己写的失败版本V1
**中心思想：**
- 每次只比较两个对称位置的节点，如果他们相等，再把他们的子节点加入队列中，等待比较

**注意点：**
- 老规矩，用LinkedList实现队列：Queue<TreeNode> q = new LinkedList<>();
- 迭代的特征就是有循环
- 我感觉我v1失败的根本原因就是没找好这两个特殊值情况。导致条件和逻辑出现纰漏而出错
- 我在v1，里是从左到右的广度遍历，再对每层切半，
再一一对应查找（虽然这里也是进行了两个节点一组的比较，但是经过队列->栈->比较，中间有太多机会出错，不如直接抓住两个节点进行比较）。
没有紧紧抓住“每次只比较两个节点”这个概念，导致问题复杂化出错。

**算法描述：**
1. 从队列的开头拿出两个节点，这两个节点存入时就决定了他们是在镜像的位置上，比较他们是否相同
2. 当前节点相同的话，之后再把他两的四个子节点，镜像对称的放一起，在放入队列的末尾，等待比较。

**代码：**
```java
public boolean isSymmetric(TreeNode root) {
    //老规矩，用LinkedList实现队列
    Queue<TreeNode> q = new LinkedList<>();
    q.add(root);
    q.add(root);
    
    //体现了迭代的特征：有循环
    while (!q.isEmpty()) {
        //取出对应位置上的两点，进行比较。这里体现了每次只比较两个节点
        TreeNode t1 = q.poll();
        TreeNode t2 = q.poll();
        
        //!!!我感觉我v1失败的根本原因就是没找好这两个特殊值情况。导致条件和逻辑出现纰漏而出错
        if (t1 == null && t2 == null) continue;
        if (t1 == null || t2 == null) return false;
        if (t1.val != t2.val) return false;
        //把对称位置的相应子节点紧挨在一起放入队列，等待下一轮迭代
        //我在v1，里是从左到右的广度遍历，没有抓住“每次只比较两个节点”这个概念，导致问题复杂化出错
        q.add(t1.left);
        q.add(t2.right);
        q.add(t1.right);
        q.add(t2.left);
    }
    //如果迭代完成后都没返回false，则说明所有节点都成对称分布，返回true
    return true;
}
```
