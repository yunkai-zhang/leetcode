### [104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)
---
#### V1,简单递归（recursion，函数里面调用自己）
**中心思想：**
- 树的总深度等于左子树和右子树里深度大的那个，再加一。而且左右子树又可以分别看成一棵树，就这么可以递归下去

**注意点：**

**算法描述：**
1. 先设置递归的中止条件：如果当前数为空，则没有深度，返回0
2. 函数最后返回，左子树和右子树里深度大的那方的深度，再加一

**代码：**
```java
public int maxDepth(TreeNode root) {
        if(root==null){
            return 0;
        }
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }

```
---

#### V2，大佬用迭代法，深度遍历和广度遍历，来求深度
**中心思想：**
- [大佬链接](https://leetcode.com/problems/maximum-depth-of-binary-tree/discuss/34195/Two-Java-Iterative-solution-DFS-and-BFS)
- 有人说这个大佬的dfs是bfs，但是我把遍历的图片画出来了,这个作者的dfs的确是dfs：![](https://github.com/yunkai-zhang/yunkai-zhang.github.io/blob/master/images/for%20github/%E6%A0%91%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86.jpg)
