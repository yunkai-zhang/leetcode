### [104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)
---
#### V1,简单递归（recursion，函数里面调用自己）
**中心思想：**
- 树的总深度等于左子树和右子树里深度大的那个，再加一。而且左右子树又可以分别看成一棵树，就这么可以递归下去

**注意点：**
- `return 1+Math.max(maxDepth(root.left),maxDepth(root.right))`中的+1很关键，这个1表示当前节点承载的一层深度

**算法描述：**
1. 先设置递归的中止条件：如果当前数为空，则没有深度，返回0。（同时这也是一个特殊情况的处理，不处理的话，后面调用空节点的子节点会发生错误）
2. 函数最后返回，左子树和右子树里深度大的那方的深度，再加一。（这个“一”表示自己这层所占用的深度）

**代码：**
```java
public int maxDepth(TreeNode root) {
        if(root==null){
            return 0;
        }
        //！！！这里的+1很关键，1表示当前节点承载的深度
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }

```
---

#### V2，大佬用迭代法，深度遍历和广度遍历，来求深度。
**中心思想：**
- [大佬链接](https://leetcode.com/problems/maximum-depth-of-binary-tree/discuss/34195/Two-Java-Iterative-solution-DFS-and-BFS)
- 有人说这个大佬的dfs是bfs，但是我把遍历的图片画出来了,这个作者的dfs的确是dfs：![](https://github.com/yunkai-zhang/yunkai-zhang.github.io/blob/master/images/for%20github/%E6%A0%91%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86.jpg)

---

#### V3，自我实现，深度遍历
**中心思想：**
- 遍历每个节点，和他们的深度。时刻更新记录的最深深度。最后返回记录的最深深度

**注意点：**
- 一定记得在`程序开头`，处理初始状态和`特殊状态`。比如这题中，如果根节点为空，后面查询空节点的左右子节点会发生运行错误。所以应预先把这种情况return 0了。
- 两个栈（stack，deep）分别记录每个节点，和该节点对应的深度。这两个栈的处理（pop和push）一定要同步，否则节点和深度就错位了
- 判断子节点不为空的方法：now.left!=null。这个可以从`代码模板`中给的treenode class的定义看出。
- 深度遍历时，先压右子节点，再压左子节点，这样弹出读取时才是先读左节点，再读右节点。符合深度遍历之先序遍历的习惯

**算法描述：**
- 见代码注释

**代码：**
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        //用深度遍历（之先序遍历）查询每个节点的深度，并记录返回最深的深度值
        
        //如果当前栈为空，则直接返回0，否则，后面查询空节点的左右子节点会发生运行错误
        //！！！一定记得在程序开头，处理初始状态和特殊状态
        if(root==null)
            return 0;
        
        //建立一个栈来保存节点
        Stack <TreeNode> stack = new Stack<>();
        //建立一个栈来保存和节点对应的深度
        Stack <Integer> deep= new Stack<>();
        
        //先存入初始化的根节点
        stack.push(root);
        //先存入根节点的深度
        deep.push(1);
        
        //记录下目前为止最深的深度
        int depMax=0;
        
        //声明当前处理的节点，备用
        TreeNode now=null;
        //声明当前节点的深度，备用
        int nDep=0;
        
        //不断遍历节点，直到节点都遍历完毕
        while(!stack.isEmpty())
        {
            //从两个栈中分别提取节点，和节点所在深度，备用
            now= stack.pop();
            nDep=deep.pop();
            
            //更新全局深度
            depMax=Math.max(depMax,nDep);
            
            //如果当前节点有左右子节点，则把它的子节点压入stack，并且在deep中压入子节点的深度（即当前深度+1）
            //！！！判断子节点不为空的方法：now.left!=null
            //先压入右节点，这样访问的时候，就可以先访问左节点，符合先序遍历的习惯
            if(now.right!=null)
            {
                stack.push(now.right);
                deep.push(nDep+1);
            }
            if(now.left!=null)
            {
                stack.push(now.left);
                deep.push(nDep+1);
            }           
            
        }
        
        //stack为空时，说明遍历完毕，返回此时记录下的最深值
        return depMax;
        
    }
}
```
