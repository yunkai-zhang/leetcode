### [104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)
---
#### V1,简单递归（recursion，函数里面调用自己）
**中心思想：**
- 树的总深度等于左子树和右子树里深度大的那个，再加一。而且左右子树又可以分别看成一棵树，就这么可以递归下去

**注意点：**

**算法描述：**
1. 先设置递归的中止条件：如果当前数为空，则没有深度，返回0
2. 函数最后返回，左子树和右子树里深度大的那方的深度，再加一

**代码：**
```java
public int maxDepth(TreeNode root) {
        if(root==null){
            return 0;
        }
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }

```
---

#### V2，大佬用迭代法，深度遍历和广度遍历，来求深度
**中心思想：**
- [下面有评论说，这个人的dfs也是广度遍历，我得自己研究一下。](https://leetcode.com/problems/maximum-depth-of-binary-tree/discuss/34195/Two-Java-Iterative-solution-DFS-and-BFS)
