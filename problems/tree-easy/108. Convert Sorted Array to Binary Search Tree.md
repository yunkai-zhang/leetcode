### [108. Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)

---

#### V1, 大佬，递归法结合二分查找思想

**中心思想：**
- 保证树里面的每个节点，在以自己为根节点的子树里的数的正中间。且每个节点的两边的子树都应该是平衡树。图见如下（要vpn）：<br/>
![](https://github.com/yunkai-zhang/yunkai-zhang.github.io/blob/master/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B6%E9%80%A0.jpg?raw=true)

**注意点：**

**算法描述：**
1. 见代码注释

**代码：**
```java
public TreeNode sortedArrayToBST(int[] num) {
    //处理特殊情况
    if (num.length == 0) {
        return null;
    }
    //返回一个平衡二叉树的根节点
    TreeNode head = helper(num, 0, num.length - 1);
    return head;
}

//该函数有二分查找的思想
public TreeNode helper(int[] num, int low, int high) {
    //最后一个可用的节点时，low=mid=high。当尝试low=low，high=mid-1（=low-1），在新一轮调用里就会出现high比low还小，此时就返回null，表示无子节点
    if (low > high) { // Done
        return null;
    }
    
    //在指针low和high之间取中间值，作为low和high之间的数所组成的树的根节点
    int mid = (low + high) / 2;
    TreeNode node = new TreeNode(num[mid]);
    
    //递归调用平衡二叉树生成器，构造左右子树
    //当此时low=mid=high时，只有一个节点，若使下一轮迭代的high等于mid-1（即low-1），则会使得high比low小，触发递归的返回条件
    node.left = helper(num, low, mid - 1);
    node.right = helper(num, mid + 1, high);
    return node;
}
```
---


